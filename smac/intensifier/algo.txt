while True
    // Incumbents are purely selected by average cost (no matter on how many trials have been evaluated)
    // Reason: If config with less trials was chosen, it will be evaluated on more trials
    // and if it performs worse than the previous incumbent, the previous incumbent becomes
    // incumbent again 
    incumbents <- rh.current_incumbents_on_pareto_front
    sort_incumbents_by_#trials <- sort(incumbents)  // incumbents with lowest trials first because of uncertainty

    // Now we get the config with the least number of trials to make it more trustworthy
    for incumbent in sort_incumbents_by_#trials
        if incumbent.#trials < max_config_calls
            // TODO: Which random trial should we get? Prioritize? First all random instances and then seeds? 
            yield get_next_random_trial(incumbent)

            // If we break here, we will sample a new configuration basically every third iteration
            // Should we first evaluate all trials on this incumbent? Then we would need
            // a break and a continue
            // Con: We get less certainty for the incumbent
            // Pro: Less computation and maybe don't spend so much time on a bad configuration
            break

    // We sample a new configuration
    if i % 2 == 0
        new_config <- get_next_config
        // TODO: Which random trial should we get? Prioritize? First all random instances and then seeds? 
        yield get_next_random_trial(new_config)
    // A configuration might be not lucky to get evaluated on a good performing trial
    // Hence, we select random configuration and give it another shot to become an incumbent
    else
        // TODO: We don't have 2*N, but it would makes sense?
        // TODO: Select configs with the least number of trials? Because they are the most uncertain
        configs <- rh.get_all_existing_configs()
        configs <- configs \ incumbents
        configs <- sort(configs)  // configs with lowest number of trials first because of uncertainty

        for config in configs:
            if #trials(config) < max_config_calls
                // TODO: Which random trial should we get? Prioritize? First all random instances and then seeds? 
                yield get_next_random_trial(config)
                break
